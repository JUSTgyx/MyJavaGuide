## 1. 索引失效的场景

> 索引失效的场景是指**在数据库查询中，虽然我们为某些字段建立了索引，但由于某些原因，查询时索引未能被使用，导致查询性能下降**。

### 1.  查询条件中使用了函数或表达式操作

- 例如：在查询中对索引列使用了 UPPER()、LOWER() 或其他函数操作，数据库无法直接利用索引
- 因为索引存储的是原始值，而不是经过函数处理后的值，类似的，对索引列进行数学运算也会使索引失效

### 2.  查询条件中使用了类型隐式转换

- 例如：索引列时字符串类型，查询条件传入的是数字类型，数据库会尝试将字符串列转换为数字进行比较
- 正确的做法是：确保查询条件的数据类型与索引列的数据类型一致。

### 3. 查询条件中使用 LIKE 并以通配符 % 开头

- 例如：LIKE '%abc' 这种查询方式会让数据库无法利用索引，因为通配符 % 开头要扫描整个表来匹配数据
- 而如果通配符出现在末尾，索引仍然可以生效

### 4. 查询条件中使用了 OR 且部分条件未命中索引

- 例如：查询条件是 `WHERE indexed_colomn = 'value' OR non_indexed_column = 'value2'`，即使 前面的列有索引，但由于后面的列没有索引，数据库可能会选择全表扫描，从而导致索引失效

### 5. 查询中使用了 NOT 或  != 操作符

- `WHERE column != 'value'` 或 `WHERE NOT column = 'value'` 这样的查询条件通常会导致数据库放弃使用索引
- 因为这类操作需要扫描大量数据来排除不符合条件的记录

### 6. 查询中使用了复合索引但未遵循最左前缀原则

- 假设有一个复合索引`(A, B, C)`，如果查询条件只包含 B 或 C，不包含 A，这个复合索引将无法被使用
- 只有从最左的咧开始，并按顺序使用索引列，才能有效利用符合索引。

### 7. 查询中使用了 IS NOT NULL

- 虽然 MySQL 支持对 IS NULL 使用索引，但在很多情况下，特别是 IS NOT NULL 的查询，数据库可能会选择全表扫描，从而导致索引失效。



## 2. B+树、B树和红黑树的特点及区别

> B+ 树、B 树和红黑树是常见的平衡树数据结构，尤其在数据库、文件系统和内存中应用的十分广泛。

### 1. 数据存储位置

- B+ 树是将所有数据存储在叶子节点，非叶子节点只存储索引键
- B 树是将数据存储在叶子节点和非叶子节点，所有节点都存储数据
- 红黑树是将每一个节点都存储数据

### 2. 叶子节点结构

- B+ 树是将叶子节点通过链表连接，是的范围查询和顺序遍历非常高效
- B 树是将叶子节点不一定通过链表连接，没有支持范围查询的结构
- 红黑树没有专门的叶子节点结构，所有节点通过指针连接

### 3. 索引查询效率上

- B+ 树是将查找操作最终都落在叶子节点完成，查找路径统一，效率较高
- B 树是将查找操作可能在非叶子节点上完成，查找路径不统一，效率较低
- 红黑树是将查找路径统一，时间复杂度为 O(log n)，每次操作通过旋转和重新染色保持平衡

### 4. 树的高度上

- B+ 树由于扇出高（每个节点存储多个键），树的高度通常较矮，查询效率较高
- B 树由于非叶子节点也存储数据，扇出较小，因此高度较高
- 红黑树是二叉搜索树，树高度相对较高，每个节点最多有两个子节点，树的深度较大

### 5. 顺序访问效率上

- B+ 树将叶子节点通过链表连接，支持搞笑的顺序访问，范围查询表现出色
- B 树是没有将直接的顺序访问机制，循序访问效率较低
- 红黑树没有顺序访问机制，顺序遍历效率较低

### 6. 磁盘 I / O 效率上

- B+ 树是将由于非叶子节点只存储索引，扇出高，可以减少磁盘访问次数，因此磁盘 I / O效率非常优秀
- B 树比 B+ 树稍差，因为非叶子节点也存储数据，删除较小，磁盘访问次数略多
- 红黑树是将磁盘 I / O 效率较差，因为树的高度较高，每次查找可能需要频繁访问磁盘

### 7. 适用场景

- B+ 树常用于数据库索引、文件系统索引，适合大规模数据的存储和检索，**尤其是需要高效范围查询时**
- B 树适用于数据库索引、文件系统索引，但相比 B+ 树，查询效率略低
- 红黑树适用于内存中的数据结构，如 Java 中的 TreeMap 和 TreeSet，适合符号表、集合、关联数组等内存数据存储

### 8. 平衡性上

- B+ 树所有叶子节点在同一层，因此平衡性非常好
- B 虽然平衡性较好，但查找路径不统一，效率略逊
- 红黑树是通过旋转和染色保持平衡，查找路径同一，操作保持平衡

### 9. 插入 / 删除操作上

- B+ 树将插入和删除操作可能引发节点分裂和合并，操作较复杂
- B 树和 B+ 树一样
- 红黑树是通过自选和染色来保持平衡，操作相对简单

### 10. 实现复杂度上

- B+ 树实现比较复杂，特别是在处理链表结构和节点分裂 / 合并时
- B 树实现较复杂，设计节点分裂 / 合并
- 红黑树实现相对简单，通过自选和染色来保持平衡

### 11. 空间利用率上

- B+ 树较高，非叶子节点只存储索引，存储效率较好
- B 树较低，非叶子节点存储数据和索引，存储效率较低
- 红黑树较高，所有节点都存储数据，由于树的平衡性，内存利用率较好



## 3. 索引的原理

> 索引（Index）时一种用于加速数据库查询操作的数据结构，他的核心作用时提升查询的速度。从本质上来说，索引的作用就是帮助快速定位有序双向链表中的元素，从而减少数据扫描的范围，提高查询效率。

### 1. 索引的基本概念

- 索引是数据库中一种独特的数据结构，它并不直接存储表中的数据，而是通过创建一个新的数据结构来指向数据表中的具体数据
- 可以把他比较字典的目录，字典目录就相当于索引表，目录项相当于索引
- 然而，索引比字典目录更加复杂，因为数据库需要处理动态的数据操作，比如插入、删除和更新等操作。这些操作会使索引发生变化，因此，数据库需要维护索引的一致性和高效性

### 2. 索引的原理

- 当你在 MySQL 中创建一个索引时，首先，MySQL 会选择一种数据结构来存储索引，常见的就是 B+ 树。
- B+ 树是一种自平衡的树形结构，叶子节点存储所有数据，而非叶子节点存储索引信息。他的每个节点包含多个键值对，每个键值对指向一个数据块。然后，索引会根据数据列的值及逆行排序，将相应的数据列指向叶子节点。
- 当你执行一个查询时，首先 MySQL 会利用索引的树结构，根据索引条件快速定位到数据的范围，而无需扫描全表。通过从根节点开始，逐层向下遍历 B+ 树，最终可以找到符合条件的数据。
- 如果索引指向的列已经包含查询条件，MySQL 可以直接从索引中获取数据，避免了全表扫描，提高了查询速度。
- 如何查询条件涉及多个列，MySQL 会使用符合索引来进一步提高查找效率，通过联合多个列的索引来加速多条件查询



## 4. 事物的隔离级别

> 事务的隔离级别是数据库管理系统（DBMS）中用于控制事务并发执行时的数据一致性和并发控制的一种机制。不同的隔离级别决定了事务在执行过程中对其他事务的可见性，从而影响了数据的完整性和查询的准确性。

### 1. 读取未提交

- 在这个隔离级别下，事务可以读取其他事务尚未提交的数据，可能会发生脏读、不可重复读、幻读。
- 当你在执行一个查询时，如果一个事务正在修改数据，但尚未提交，其他事务仍然可以看到这个未提交的数据。
- 这虽然提供了最高的并发性，但也带来了数据一致性的风险，如果读取到不一致的数据。

### 2. 读取已提交

- 事务只能读取其他事务已提交的数据，可能会发生不可重复的、幻读
- 当你在执行一个查询时，只有那些已经提交的事务对当前事务可见。
- 不可重复读的问题依然存在：如果在同一个事务中多次查询相同的数据，可能会得到不同的结果，因为其他事务可能在查询期间修改了数据

### 3. 可重复读

- 事务在执行期间会锁定查询的数据行，确保该数据在事务完成前不会被其他事务修改。
- 执行一个查询时，同一个事务中的查询结果不会改变，即使其他事务修改了数据，当前事务也看不到变化的数据。
- 然后这个级别仍然存在幻读问题，即在查询中：其他事务可能会插入新的数据行，导致当前事务查询的数据集发生变化。

### 4. 可串行化

- 事物的执行会像是串行执行的，即一个事务执行完成后，另一个事务才能开始。
- 在执行一个查询时，不仅当前查询的数据不会被修改，其他食物也不能插入新的数据行。
- 这个级别提供了最高的事务一致性，但代价是性能的显著下降，因为它限制了并发操作。

## 5. 慢查询优化

> 慢查询优化的关键在于启用慢查询日志并进行深入分析，这能帮助我们识别和优化那些执行效率低下的 SQL 语句。总体通过三个步骤：先捕获低效 SQL，然后使用工具进行分析，最后采用一些方法和原则进行优化。

### 1. 捕获低效 SQL

- 在此时，我们需要确保慢查询日志已经启用
- 通过设置全局变量`slow_query_log`为 'ON' 来开启此功能，并设定 `long_query_time` 参数以去欸的那个什么成都的查询延迟被视为“慢”。可以使用 `SHOW VARIABLES` 命令来检查这两个设置的状态。

### 2. 分析慢查询日志

- 这是找出问题根源的关键步骤。利用工具如 `mysqldumpslow` 可以帮助我们总结日志信息，比如按出现频率或者总执行时间排序，从而聚焦于最需要关注的查询语句。
- 对于每一个查询，我们可以使用 EXPLAIN 命令来查看 MySQL 如何执行这些查询。EXPLAIN 提供的输出能够揭示查询执行计划中的细节，例如：**是否执行了全表扫描（ALL）**，**以及哪些索引被使用**等。根据这些信息我们可能做出更明智的决策来优化查询性能。

### 3. 采用一些方法和原则进行优化

1. 建立和优化索引：合理的索引设计可以让查询更加高效
2. 对查询本身进行优化：避免不必要的列选择，尽量减少数据传输量，并考虑使用批量或分页查询来处理大数据集。此外，**尽量使用 JOIN 替代子查询**，因为**JOIN 通常具有更好的性能表现**。
3. 调整数据库和系统的配置参数：例如：**适当增大 InnoDB 缓冲池大小**、**调整临时表的大小限制等**。都可以带来显著的性能改进
4. 对于特别大的表，可以考虑采用水平切分或垂直切分策略，通过将**数据分散到多个表或数据库实例中**，进一步减轻单个实例的压力，改善整体查询性能。



## 6. 索引的分类

### 1. 按数据结构分类

- B+ 树索引
- Hash 索引
- Full-text 索引

### 2. 按物理存储分类

- 聚簇索引
- 二级索引（非聚簇索引）

### 3.按字段特性分类

- 主键索引
- 唯一索引
- 前缀索引

### 4. 按字段个数分类

- 单列索引
- 联合索引

## 7. 聚簇索引和非聚簇索引的区别

聚簇索引和非聚簇索引在数据存储方式上存在显著差别

### 聚簇索引

- 叶子节点保存了实际的数据记录，这意味着所有用户数据都与索引结构紧紧结合在一起，
- 这种设计使得 InnoDB 存储引擎在创建表时会自动为每个表生成一个聚簇索引，以保证数据的高效访问。
- 然而由于物理存储的限制，一张表只能有一个聚簇索引

### 非聚簇索引

- 非聚簇索引的叶子节点并不直接包含数据，二十存储了指向主键值的指针。
- 这意味着当前查询使用非聚簇索引时秒如果需要获取完整的数据行，系统必须先通过非聚簇索引找到主键，再通过聚簇索引获取完整的数据信息，这一过程被称为回表。
- 只有查询条件完全覆盖了非聚簇索引中的字段时，才能避免回表操作，这被称为“索引覆盖”。

> InnoDB 在选择聚簇索引的列时，遵循一定的规则：
>
> - **如果有定义主键，将优先使用主键作为聚簇索引**
> - **若无主键，则会选择第一个不包含 NULL 值的唯一列作为聚簇索引**
> - 在以上条件都不满足的情况下，**InnoDB 会自动生成一个隐式自增 ID 作为聚簇索引的依据**

