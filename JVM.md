## 1. 对象创建的过程

> 对象的创建过程是 Java 虚拟机（JVM）中一个非常重要的环节，主要分五步

### 1. 类加载检查

1. 当程序执行到 new 指令时，JVM 会先检查对应的类**是否已经被加载、解析和初始化。**
2. 如果类**尚未加载**，JVM 会按照类加载机制（加载、验证、准备、解析、初始化）完成类的加载过程。
3. 这一步确保了类的元信息（字段、方法等）已经准备好，为后续创建对象奠定基础。

### 2. 内存的分配

> JVM 会为新对象分配内存空间

- 对象所需的内存大小在类加载完成后就可以确定，因此分配内存的过程就是从**堆**中划分一块连续的空间
- 主要有两种方式：
  1. 指针碰撞：如果堆中的内存是规整的（已使用区域和空闲区与之间有明确分界），JVM 可以通过移动指针来分配内存。
  2. 空闲列表：如果堆中内存是碎片化的，JVM 会维护一个**空闲列表**，记录可用的内存块，并从中分配合适的区域。

### 3. 零值初始化

> JVM会对分配的内存空间进行初始化，将其所有字段设置为零值（int -> 0, boolean -> false, 引用 -> null）。

- 这一步确保了对象的实例字段在**未显示赋值前**有一个默认值，从而避免未初始化的变量被访问。

### 4. 设置请求头

- 包含：Mark Word、Klass Pointer 和数组长度。
- **Mark Word** 用于存储对象的哈希码、GC 分代年龄、锁状态标志等信息。
- **Klass Pointer** 只想对象所属类的元数据（即 Person.class 的地址）

### 5. 执行构造方法

1. 用 `<init> `方法 完成对象的初始化
2. 构造方法会根据代码逻辑 对 对象的字段进行赋值，并调用父类的构造方法完成继承链的初始化。

> 这一步完成后，对象才真正可用



## 2. 类载入 JVM 会做什么

> 类的加载过程确保了**类在运行时能够被正确地使用**，分为五个阶段：**加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）和 初始化（Initialization）。**

### 1. 加载阶段

> 在这个阶段，JVM 会做三件事

1. 首先**通过类的全限定名获取定义此类的二进制字节流**，可以通过多种方式实现，例如：从本地文件系统加载 .class 文件、从网络下载、或者通过动态代理生成字节码。
2. 然后**将字节流所代表的静态存储结构转化为方法区的运行时的数据结构**，即 将类的元信息（字段、方法、父类等）存储到方法区中。
3. 最后**在堆中生成一个代表该类的 `java.lang.Class` 对象**，这个对象作为程序访问该类的入口点，所有的反射操作都要通过这个对象进行。

### 2. 验证阶段

> 在这个阶段，JVM 会对加载的字节码进行校验，以确保其符合 Java 虚拟机规范，并且不会危害虚拟机的安全，会验证四样东西

1. **文件格式**，检查字节码文件是否符合 Class 文件格式规范
2. **元数据**，检查类的元信息是否符合语法规则，例如父类是否存在，是否继承了 final 类等
3. **字节码**，分析字节码指令，确保其不会执行非法操作（如类型转换错误、数组越界访问等）
4. **符号引用**，检查符号引用是否能正确解析为直接引用，例如检查类、字段、方法是否存在并且可访问

### 3. 准备阶段

> JVM 会为类的静态变量分配内存，并设置默认初始值（零值）。这个阶段**不会执行任何 Java 代码**，**也不会为实例变量分配内存（实例变量是在对象创建时分配的）**。

- 例如，如果类中有一个静态变量 `static int value = 123`，在这个阶段 value 会被初始为 0，而不是 123**（赋值操作在初始化阶段完成）**

### 4. 解析阶段

> JVM 会将类中的符号引用替换为直接引用

- **符号引用**是以一组符号描述所引用的目标，例如：类的全限定名、字段的名称和描述符等。
- **直接引用**是可以定位到目标的指针、句柄或偏移量。解析的对象包括类或接口、字段、方法、方法类型、方法句柄和调用点限定符等。

### 5. 初始化阶段

> JVM 会执行类的初始化代码，包括：**静态变量赋值和静态代码块的执行**

- 这是类加载过程的最后一个阶段，也是唯一一个会执行用户代码的阶段。
- 初始化的顺序遵循**父类优先**的原则，即先初始化父类，再初始化子类。



## 3. 双亲委派模型

> 双亲委派模型是 Java 类加载机制的核心概念，他**定义了类加载器之间的层次关系和加载规则**。通过这种模型，Java 能够保证**类的唯一性和安全性，同时避免重复加载类的问题**。

### 1. 什么是双亲委派模型

它其实是一种类加载机制，其规定了：

- 当一个类加载器收到类加载请求时，不会立即尝试自己去加载这个类
- 而是会现将请求委托给父类加载器完成。
- 只有当父类加载器无法加载该类（例如父类的搜索范围内找不到对应的类）时，子类加载器才会尝试自己加载。
- 这种机制确保了类的加载过程具有层次性，并且优先使用高层级的类加载器来加载核心类库。

### 2. 类加载器的层次结构

1. 启动类加载器：负责加载 JVM 核心类库（如 `rt.jar` 中的类），位于最顶层，通常由本地代码实现。
2. 扩展类加载器：负责加载 `$JAVA_HOME/lib/ext` 目录下的扩展类库
3. 应用程序类加载器：负责加载用户**类路径（ClassPath）上的类，也成为系统类加载器。
4. 自定义类加载器：开发者可以通过继承 `ClassLoader` 类实现自己的类加载器，用于加载特定需求的类。

这些类加载器之间形成了一个树状的层次结构，每个类加载器都有一个父加载器。

### 3. 双亲委派模型工作流程

1. 检查缓存：当前类加载器会先检查是否一家在国该目标，如果已加载，则直接返回对应的 Class 对象
2. 委派父加载器：如果没有加载过，当前类会将加载请求委派给父加载器处理
3. 递归向上：父加载器继续将请求委派给他的父加载器，直到到达启动类加载器
4. 尝试加载：如果父加载器无法加载目标类，则子加载器会尝试自己加载

### 4. 双亲委派模型优势

1. 类的唯一性：通过双亲委派模型，同一个类只会被一个类加载器加载一次，从而避免了重复加载的问题。
2. 安全性：核心类库（如 java.lang.String）由 Bootstrap ClassLoader 加载，防止用户自定义的恶意类冒充核心类库。
3. 模块化管理：不同层级的类加载器负责加载不同范围的类，便于实现模块化和隔离性。



## 4. JVM 的内存区域

> JVM 的内存区域可以分为线程共享和线程私有两部分，每个部分都有明确的职责和作用。下面是 JDK1.7 时 JVM 内存结构

### 1. 线程共享的部分

1. 堆：所有对象实例和数组都在这里分配内存，垃圾回收器（GC）会管理器中的对象回收。堆中还包括了**字符串常量池**，用于存储字符串字面量和常量。
2. 方法区：用于存储类的元信息、静态变量、常量、方法字节码等。其中 运行时常量池 是方法区的一部分，用于存储**编译期生成的各种字面量和符号引用**。

### 2. 线程私有的部分

1. 虚拟机栈：每个线程启动时都会创建一个虚拟机栈，他存储方法调用过程中产生的栈帧，包括局部变量、操作数栈、方法返回地址等，每个方法调用都会创建一个新的栈帧，方法执行结束后栈帧出栈。
2. 本地方法栈：专门用于存储本地方法的调用信息，与虚拟机栈类似，但用于 JNI（Java Native Interface）调用。
3. 程序计数器：记录当前线程正在执行的字节码指令地址。他是 JVM 运行时最小的内存区域，每个线程都有一个独立的程序计数器。

### 3. 本地内存

- 包含**直接内存**，由 NIO（New Input / Output）直接分配，不受 JVM 堆的管理，通常用于高性能数据传输，如缓冲区（Buffer）。
- 这个内存结构保证了  JVM 在执行 Java 代码时能够高效管理对象、执行方法调用，并支持多线程并发。

> JDK 1.8 时 JVM 的内存结构主要有三点不同

### 4. 不同

1. **方法区** 在 JDK 1.8 被移除，替换为 元空间，且元空间使用本地内存，而非 JVM 堆。
2. **字符串常量池** 在 JDK 1.7 位于方法区，而在 JDK 1.8 被移动到 堆中，降低了方法区的压力。
3. **运行时常量池** 在 JDK 1.7 属于方法去的一部分，而在 JDK 1.8 中变成了 元空间的一部分。



## 5. 垃圾回收算法

> 垃圾回收（Garbage Collection，简称 GC）是 Java 虚拟机（JVM）中自动管理内存的重要机制，它通过一系列算法来识别和回收不再使用的对象，从而释放堆内存。

### 1. 标记-清除算法

> 是最基础的垃圾回收算法

1. 标记阶段：从根对象（GC Roots）开始，递归遍历所有可达对象，并标记为 “存活”；
2. 清楚阶段：遍历整个堆内存，回收未被标记的对象所占用的空间。

该算法存在两个问题：

1. 内存碎片化，回收后的内存可能会产生大量不连续的碎片，导致大对象无法分配内存；
2. 效率较低，需要遍历两次堆内存，耗时较长。

### 2. 复制算法

通过将内存划分为两块（From 和 To），每次只使用其中一块，解决了标记-清楚算法的内存碎片化问题，主要分为两个阶段

1. 复制阶段：当一块内存用完时，将存活的对象复制到另一块内存中，并按顺序排列；
2. 清理阶段：直接清空原来的内存块，无需额外的标记或者清除操作。

- 优点：效率高不会产生内存碎片
- 缺点：需要双倍的内存空间

### 3. 标记-整理算法

它是对标记-清除算法的改进，它在标记阶段完成后，会将所有存活对象向一端移动，从而避免内存碎片化。

1. 标记阶段：与标记-清除算法相同，标记所有存活的对象；
2. 整理阶段：将存活对象移动到内存另一端，清理边界外的内存。

此算法适合老年代，因为老年代中的对象存活率较高，复制成本较大。

### 4. 分代收集算法

是目前主流 JVM 的垃圾回收策略，它基于对象的生命周期将堆内存划分为新生代和老年代

1. 对于 新生代：大多数对象朝生夕灭，采用复制算法进行垃圾回收。新生代进一步划分为 Eden 区和两个 Survivor 区（From 和 To）
2. 对于 老年代：存活时间较长的对象存储在此，次啊用标记-清除或标记-整理算法进行垃圾回收

这种算法结合了不同算法的优点，针对不同代的特点选择合适的回收策略，从而提升整体性能。



## 6. 垃圾回收器

> Java 的垃圾回收机制通过标记垃圾对象和回收无用内存，提升内存利用率，降低程序停顿时间。垃圾回收器是具体实现算法的工具，常见的两种垃圾回收器是：CMS 和 G1，分别用于不同场景

### 1. CMS 收集器

CMS 是以**最小化停顿时间**为目标的垃圾收集器，适用于需要高响应的应用场景（如 Web 应用）。基于 **标记-清除算法**，回收流程包括以下阶段：

1. 首先停止所有用户线程，启用一个 GC 线程进行**初始标记**（Stop The World），标记 GC Roots 能直接引用的对象，停顿时间短。
2. 其次用户线程和 GC  线程并发执行，进行**并发标记**，用户线程和 GC 线程并发执行，完成从 GC Roots 开始的对象引用分析。
3. 然后，启动多个 GC 线程进行**重新标记**（Stop The World），修正并发标记期间用户线程对对象引用的变动，停顿时间稍长但可控。
4. 最后，启动多个用户线程和一个 GC 线程，进行**并发清除**，清理不可达对象，清理完成后把 GC 线程进行重置。

- 优点：响应时间优先，停顿时间短
- 缺点：一个是由于 CMS 采用 “标记-清除”，会导致内存碎片积累；另一个是由于在并发清理过程中仍有用户线程运行，可能生成新的垃圾对象，需在下次 GC 处理。

### 2. G1 收集器

G1 收集器以**GC 停顿时间**为目标，兼具**高吞吐量和低延迟性能**，适用于大内存、多核环境。其基于 “标记-整理” 和 “标记-复制算法”，包括下面几个阶段

1. 首先，停止所有用户线程，启用一个 GC 线程进行**初始标记**（Stop The World），标记从 GC Roots 可达的对象，时间短。
2. 其次，让用户线程和一个 GC 线程并发工作，用 GC 线程进行**并发标记**，分析整个堆中内存的存活情况。
3. 然后，停止所有用户线程，让多个 GC 线程进行**最终标记**（Stop The World），修正并发标记阶段所产生的引用变动，识别即将被回收的对象。
4. 最后，让多个 GC 线程及逆行筛选回收，根据收集时间预算，优先回收回收价值最高的 Region。回收完成后把 GC 线程重置。这是 G1 的核心优化，基于堆分区，将回收工作集中于垃圾最多的区域，避免全堆扫描。

- 优点：
  1. 将堆内存划分为多个 Region，可分别执行标记、回收，提升效率。
  2. 采用 “标记-整理” 和 “标记-复制”，实现内存紧凑化。
  3. 方便控制停顿时间，通过后台维护的优先队列，动态选择高价值的 Region，极大减少了全堆停顿的频率。
- 缺点：调优复杂，堆硬件资源要求较高。



